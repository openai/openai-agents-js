name: Release PR Review

on:
  workflow_run:
    workflows: ['Changesets Release']
    types: [completed]
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'Release PR number (changeset-release/*) to review'
        required: true
        type: number

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  review:
    if: github.repository_owner == 'openai' && ( (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') || github.event_name == 'workflow_dispatch')
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - name: Find open release PR
        id: pr
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd
        env:
          MANUAL_PR_NUMBER: ${{ github.event.inputs.pr_number || '' }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const headBranch = context.payload.workflow_run?.head_branch;
            const manualPr = process.env.MANUAL_PR_NUMBER;

            if (context.eventName === 'workflow_dispatch') {
              if (!manualPr) {
                core.setFailed('workflow_dispatch requires pr_number input.');
                return;
              }
              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: Number(manualPr),
              });
              if (!pr.head.ref.startsWith('changeset-release/')) {
                core.setFailed(`PR #${manualPr} is not a changeset-release/* PR.`);
                return;
              }
              core.info(`Found PR #${pr.number} (${pr.head.ref}) via workflow_dispatch input.`);
              core.setOutput('found', 'true');
              core.setOutput('pr_number', pr.number);
              core.setOutput('head_sha', pr.head.sha);
              return;
            }

            const searchQuery = `repo:${context.repo.owner}/${context.repo.repo} is:pr is:open head:changeset-release/`;
            const { data: searchResults } = await github.rest.search.issuesAndPullRequests({
              q: searchQuery,
              per_page: 50,
            });

            const candidates = await Promise.all(
              searchResults.items.map(async (item) => {
                const { data: pr } = await github.rest.pulls.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: item.number,
                });
                return pr;
              })
            );

            candidates.sort((a, b) => new Date(b.updated_at) - new Date(a.updated_at));

            if (headBranch) {
              const match = candidates.find((pr) => pr.head.ref === headBranch);
              if (match) {
                core.info(`Found PR #${match.number} (${match.head.ref})`);
                core.setOutput('found', 'true');
                core.setOutput('pr_number', match.number);
                core.setOutput('head_sha', match.head.sha);
                return;
              }
            }

            const pr = candidates[0];
            if (!pr) {
              core.info('No open release PR found (changeset-release/*). Skipping.');
              core.setOutput('found', 'false');
              return;
            }

            core.info(`Found PR #${pr.number} (${pr.head.ref})`);
            core.setOutput('found', 'true');
            core.setOutput('pr_number', pr.number);
            core.setOutput('head_sha', pr.head.sha);

      - name: Checkout release PR head
        if: steps.pr.outputs.found == 'true'
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8
        with:
          ref: ${{ steps.pr.outputs.head_sha }}
          fetch-depth: 0

      - name: Fetch tags
        if: steps.pr.outputs.found == 'true'
        run: git fetch origin --tags --prune

      - name: Generate final-release-review prompt
        if: steps.pr.outputs.found == 'true'
        id: prompt
        run: |
          BASE_TAG="$(.codex/skills/final-release-review/scripts/find_latest_release_tag.sh origin 'v*')"
          TARGET="${{ steps.pr.outputs.head_sha }}"
          export BASE_TAG TARGET

          PROMPT_DIR=".tmp/codex/prompts"
          OUTPUT_DIR=".tmp/codex/outputs"
          PROMPT_FILE="${PROMPT_DIR}/final-release-review.generated.md"
          OUTPUT_FILE="${OUTPUT_DIR}/review.md"

          mkdir -p "$PROMPT_DIR" "$OUTPUT_DIR"

          cat > "$PROMPT_FILE" <<-EOF
          You are Codex running inside a GitHub Actions job for openai/openai-agents-js.

          Goal: Execute the \$final-release-review skill and emit the markdown comment to post on the release PR. Use the skill instructions at .codex/skills/final-release-review/SKILL.md.

          Context you must use:
          - BASE_TAG: ${BASE_TAG}
          - TARGET: ${TARGET}
          - Workspace: repository is already checked out at TARGET with full history and tags fetched.
          - Output file path: review.md (write the final comment here).

          Skill invocation:
          \$final-release-review

          Requirements:
          1) Run the \$final-release-review skill end-to-end (follow the checklist and heuristics in the skill + references). Do NOT just print git diff stats; perform the heuristic review the skill expects (breaking-change candidates, regression risks, improvement opportunities, release gate recommendation).
          2) Base your analysis on the diff ${BASE_TAG}...${TARGET}. You may run git commands as needed (read-only workspace is fine).
          3) Output must be valid markdown, starting with the marker line: \`<!-- final-release-review -->\`
          4) After the marker, include a concise report with:
             - Summary header similar to the skill format (base tag, target, generated timestamp in UTC ISO8601).
             - High-level diff insights (key directories/files, counts) and risk callouts per the checklist.
             - Breaking change candidates, regression risks, improvement opportunities, and any missing release notes/migrations.
             - A ship/block recommendation with any required follow-up checks.
          5) Keep the comment self-contained and readable for a PR.

          Produce only the markdown comment. Do not wrap in code fences. Save the entire comment to review.md.
          EOF

          echo "prompt_file=${PROMPT_FILE}" >> "$GITHUB_OUTPUT"
          echo "output_file=${OUTPUT_FILE}" >> "$GITHUB_OUTPUT"
          echo "BASE_TAG=${BASE_TAG}" >> "$GITHUB_OUTPUT"
          echo "TARGET=${TARGET}" >> "$GITHUB_OUTPUT"

      - name: Run Codex final-release-review
        if: steps.pr.outputs.found == 'true'
        id: review
        uses: openai/codex-action@086169432f1d2ab2f4057540b1754d550f6a1189
        with:
          openai-api-key: ${{ secrets.PROD_OPENAI_API_KEY }}
          prompt-file: ${{ steps.prompt.outputs.prompt_file }}
          output-file: ${{ steps.prompt.outputs.output_file }}
          sandbox: danger-full-access
          safety-strategy: drop-sudo

      - name: Upsert PR comment
        if: steps.pr.outputs.found == 'true'
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd
        env:
          PR_NUMBER: ${{ steps.pr.outputs.pr_number }}
          REVIEW_PATH: ${{ steps.prompt.outputs.output_file }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const body = fs.readFileSync(process.env.REVIEW_PATH, 'utf8');
            const marker = '<!-- final-release-review -->';

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: Number(process.env.PR_NUMBER),
              per_page: 100,
            });

            const existing = comments.find(
              (c) => c.user?.login === 'github-actions[bot]' && c.body?.includes(marker)
            );

            if (existing) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body,
              });
              core.info(`Updated existing comment ${existing.id}`);
            } else {
              const { data: created } = await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: Number(process.env.PR_NUMBER),
                body,
              });
              core.info(`Created comment ${created.id}`);
            }
