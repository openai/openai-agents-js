---
title: 音声エージェントの構築
description: Learn how to build voice agents using the OpenAI Agents SDK, what features are available, how to architecture your application, and more.
---

import { Steps, Aside, Code } from '@astrojs/starlight/components';
import createAgentExample from '../../../../../../../examples/docs/voice-agents/createAgent.ts?raw';
import multiAgentsExample from '../../../../../../../examples/docs/voice-agents/multiAgents.ts?raw';
import createSessionExample from '../../../../../../../examples/docs/voice-agents/createSession.ts?raw';
import configureSessionExample from '../../../../../../../examples/docs/voice-agents/configureSession.ts?raw';
import handleAudioExample from '../../../../../../../examples/docs/voice-agents/handleAudio.ts?raw';
import defineToolExample from '../../../../../../../examples/docs/voice-agents/defineTool.ts?raw';
import toolApprovalEventExample from '../../../../../../../examples/docs/voice-agents/toolApprovalEvent.ts?raw';
import guardrailsExample from '../../../../../../../examples/docs/voice-agents/guardrails.ts?raw';
import guardrailSettingsExample from '../../../../../../../examples/docs/voice-agents/guardrailSettings.ts?raw';
import audioInterruptedExample from '../../../../../../../examples/docs/voice-agents/audioInterrupted.ts?raw';
import sessionInterruptExample from '../../../../../../../examples/docs/voice-agents/sessionInterrupt.ts?raw';
import sessionHistoryExample from '../../../../../../../examples/docs/voice-agents/sessionHistory.ts?raw';
import historyUpdatedExample from '../../../../../../../examples/docs/voice-agents/historyUpdated.ts?raw';
import updateHistoryExample from '../../../../../../../examples/docs/voice-agents/updateHistory.ts?raw';
import customWebRTCTransportExample from '../../../../../../../examples/docs/voice-agents/customWebRTCTransport.ts?raw';
import websocketSessionExample from '../../../../../../../examples/docs/voice-agents/websocketSession.ts?raw';
import transportEventsExample from '../../../../../../../examples/docs/voice-agents/transportEvents.ts?raw';
import thinClientExample from '../../../../../../../examples/docs/voice-agents/thinClient.ts?raw';
import toolHistoryExample from '../../../../../../../examples/docs/voice-agents/toolHistory.ts?raw';
import sendMessageExample from '../../../../../../../examples/docs/voice-agents/sendMessage.ts?raw';
import serverAgentExample from '../../../../../../../examples/docs/voice-agents/serverAgent.ts?raw';
import delegationAgentExample from '../../../../../../../examples/docs/voice-agents/delegationAgent.ts?raw';
import turnDetectionExample from '../../../../../../../examples/docs/voice-agents/turnDetection.ts?raw';

## 音声の処理

デフォルトの `OpenAIRealtimeWebRTC` のような一部のトランスポート層は、音声の入力と出力を自動で処理します。`OpenAIRealtimeWebSocket` のような他のトランスポート機構では、セッションの音声を自分で扱う必要があります:

<Code lang="typescript" code={handleAudioExample} />

## セッションの設定

作成時に [`RealtimeSession`](/openai-agents-js/openai/agents-realtime/classes/realtimesession/) に追加オプションを渡すか、`connect(...)` を呼び出す際に渡して、セッションを設定できます。

<Code lang="typescript" code={configureSessionExample} />

これらのトランスポート層では、[セッション](https://platform.openai.com/docs/api-reference/realtime-client-events/session/update) に一致する任意のパラメーターを渡せます。

新しく [RealtimeSessionConfig](/openai-agents-js/openai/agents-realtime/type-aliases/realtimesessionconfig/) に対応するパラメーターが存在しない項目は、`providerData` を使用できます。`providerData` に渡したものは `session` オブジェクトの一部としてそのまま渡されます。

## ハンドオフ

通常のエージェントと同様に、ハンドオフを使ってエージェントを複数のエージェントに分割し、それらをオーケストレーションしてエージェントのパフォーマンスを向上させ、問題の範囲をより適切に絞り込めます。

<Code lang="typescript" code={multiAgentsExample} />

通常のエージェントと異なり、リアルタイムエージェントにおけるハンドオフの挙動は少し異なります。ハンドオフが実行されると、進行中のセッションが新しいエージェント構成で更新されます。このため、エージェントは進行中の会話履歴に自動的にアクセスでき、入力フィルターは現在適用されません。

さらに、`voice` や `model` はハンドオフの一部として変更できないことを意味します。接続できるのは他のリアルタイムエージェントのみです。別のモデル、たとえば `o4-mini` のような推論モデルを使う必要がある場合は、[delegation through tools](#delegation-through-tools) を利用できます。

## ツール

通常のエージェントと同様に、リアルタイムエージェントはアクションを実行するためにツールを呼び出せます。通常のエージェントと同じ `tool()` 関数でツールを定義できます。

<Code lang="typescript" code={defineToolExample} />

リアルタイムエージェントで使用できるのは関数ツールのみで、これらのツールはリアルタイムセッションと同じ場所で実行されます。つまり、ブラウザーでリアルタイムセッションを実行している場合、ツールもブラウザーで実行されます。より機密性の高い操作を行う必要がある場合は、ツール内からバックエンド サーバーへの HTTP リクエストを発行できます。

ツールの実行中は、エージェントはユーザーからの新しいリクエストを処理できません。体験を向上させる方法の一つは、ツールを実行しようとしているときにそれをアナウンスする、あるいはツールの実行時間を確保するための特定のフレーズをエージェントに言わせるよう指示することです。

### 会話履歴へのアクセス

エージェントが特定のツールを呼び出す際に渡した引数に加えて、リアルタイムセッションが追跡している現在の会話履歴のスナップショットにもアクセスできます。これは、会話の現在の状態に基づいてより複雑な処理を行う必要がある場合や、[tools for delegation](#delegation-through-tools) を使う予定がある場合に役立ちます。

<Code lang="typescript" code={toolHistoryExample} />

<Aside type="note">
  渡される履歴は、ツール呼び出し時点のスナップショットです。ユーザーが最後に話した内容の書き起こしは、まだ利用できない場合があります。
</Aside>

### ツール実行前の承認

ツールを `needsApproval: true` で定義すると、エージェントはツールを実行する前に `tool_approval_requested` イベントを発行します。

このイベントをリッスンして、ツール呼び出しを承認または拒否するための UI をユーザーに表示できます。

<Code lang="typescript" code={toolApprovalEventExample} />

<Aside type="note">
  音声エージェントがツール呼び出しの承認を待っている間、エージェントはユーザーからの新しいリクエストを処理できません。
</Aside>

## ガードレール

ガードレールは、エージェントの発話が一連のルールに違反していないかを監視し、違反があれば即座に応答を打ち切る手段を提供します。これらのガードレールチェックはエージェントの応答の書き起こしに基づいて行われるため、モデルのテキスト出力が有効である必要があります（デフォルトで有効です）。

提供したガードレールは、モデルの応答が返ってくるのに合わせて非同期に実行され、あらかじめ定義した分類トリガー（例:「特定の禁止ワードに言及した」）に基づいて応答を打ち切れます。

ガードレールが反応すると、セッションは `guardrail_tripped` イベントを発行します。イベントには、ガードレールをトリガーした `itemId` を含む `details` オブジェクトも含まれます。

<Code lang="typescript" code={guardrailsExample} />

既定では、ガードレールは 100 文字ごと、または応答テキストの生成が完了した時点で実行されます。音声で読み上げる方が通常は時間がかかるため、多くの場合、ユーザーが聞く前にガードレールが違反を検知できます。

この動作を変更したい場合は、セッションに `outputGuardrailSettings` オブジェクトを渡します。

<Code lang="typescript" code={guardrailSettingsExample} />

## ターン検出 / 音声活動検出

リアルタイムセッションは、ユーザーが話しているタイミングを自動検出し、内蔵の [Realtime API の音声活動検出モード](https://platform.openai.com/docs/guides/realtime-vad) を使って新しいターンを開始します。

音声活動検出モードは、セッションに `turnDetection` オブジェクトを渡すことで変更できます。

<Code lang="typescript" code={turnDetectionExample} />

ターン検出の設定を調整すると、不要な割り込みの抑制や無音への対処に役立ちます。設定の詳細は [Realtime API のドキュメント（各種設定の詳細）](https://platform.openai.com/docs/guides/realtime-vad) を参照してください

## 割り込み

内蔵の音声活動検出を使用している場合、エージェントの発話に被せて話すと、自動的にエージェントがそれを検知し、発話内容に基づいてコンテキストを更新します。同時に `audio_interrupted` イベントも発行します。これは、すべての音声再生を即座に停止するために使用できます（ WebSocket 接続にのみ適用）。

UI に「停止」ボタンを用意するなど、手動で割り込みを行いたい場合は、`interrupt()` を明示的に呼び出せます:

<Code lang="typescript" code={sessionInterruptExample} />

いずれの場合も、リアルタイムセッションはエージェントの生成を中断し、ユーザーに対して発話した内容の認識を切り詰め、履歴を更新します。

エージェントに接続するのに WebRTC を使用している場合、音声出力もクリアされます。 WebSocket を使用している場合は、再生キューに入っている音声の再生を停止するなど、この処理を自分で行う必要があります。

## テキスト入力

エージェントにテキスト入力を送信したい場合は、`RealtimeSession` の `sendMessage` メソッドを使用できます。

これは、ユーザーがエージェントと音声・テキストの両モダリティでやり取りできるようにしたい場合や、会話に追加のコンテキストを提供したい場合に便利です。

<Code lang="typescript" code={sendMessageExample} />

## 会話履歴の管理

`RealtimeSession` は会話履歴を `history` プロパティで自動的に管理します:

これを使用して、履歴を顧客に表示したり、追加の処理を行ったりできます。会話の進行中はこの履歴が継続的に変化するため、`history_updated` イベントをリッスンできます。

メッセージを完全に削除する、書き起こしを更新するなど、履歴を変更したい場合は、`updateHistory` メソッドを使用できます。

<Code lang="typescript" code={updateHistoryExample} />

### 制限事項

1. 現時点では、関数ツールの呼び出しを後から更新/変更できません
2. 履歴内のテキスト出力には、書き起こしとテキストモダリティを有効にする必要があります
3. 割り込みにより途中で切り詰められた応答には、書き起こしがありません

## ツールによる委譲

![ツールによる委譲](https://cdn.openai.com/API/docs/diagram-speech-to-speech-agent-tools.png)

会話履歴とツール呼び出しを組み合わせることで、会話を別のバックエンドのエージェントに委譲して、より複雑な処理を実行し、その結果をユーザーに返すことができます。

<Code lang="typescript" code={delegationAgentExample} />

以下のコードはサーバーで実行されます。この例では Next.js の server actions を通じて実行されます。

<Code lang="typescript" code={serverAgentExample} />
